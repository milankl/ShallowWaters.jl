var documenterSearchIndex = {"docs":
[{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"../assets/swm_equations.jl\"","category":"page"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"(Image: Binder)","category":"page"},{"location":"swm_equations/#ShallowWaters.jl-The-equations","page":"Tutorial","title":"ShallowWaters.jl - The equations","text":"","category":"section"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"The shallow water equations for the prognostic variables velocity mathbfu = (uv) and sea surface elevation eta over the 2-dimensional domain Omega in xy are","category":"page"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"beginalign\npartial_t u + upartial_xu + vpartial_yu - fv = -gpartial_xeta + D_x(uveta) + F_x \npartial_t v + upartial_xv + vpartial_yv + fu = -gpartial_yeta + D_y(uveta) + F_y \npartial_t eta + partial_x(uh) + partial_y(vh) = 0\nendalign","category":"page"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"where the first two are the momentum equations for uv and the latter is the continuity equation. The layer thickness is h = eta + H with H=H(xy) being the bottom topography. The gravitational acceleration is g, the coriolis parameter f = f(y) depends only (i.e. latitude) only and the beta-plane approximation is used. (D_xD_y) = mathbfD are the dissipative terms","category":"page"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"mathbfD = -fracc_Dhvert mathbfu vert mathbfu - u nabla^4mathbfu","category":"page"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"which are a sum of a quadratic bottom drag with dimensionless coefficient c_D and a biharmonic diffusion with viscosity coefficient u. mathbfF = (F_xF_y) is the wind forcing which can depend on time and space, i.e. F_x = F_x(xyt) and F_y = F_y(xyt).","category":"page"},{"location":"swm_equations/#The-vector-invariant-formulation","page":"Tutorial","title":"The vector invariant formulation","text":"","category":"section"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"The Bernoulli potential p is introduced as","category":"page"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"p = frac12(u^2 + v^2) + gh","category":"page"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"The relative vorticity zeta = partial_xv + partial_yu lets us define the potential vorticity q as","category":"page"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"q = fracf + zetah","category":"page"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"such that we can rewrite the shallow water equations as","category":"page"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"beginalign\npartial_t u = qhv -gpartial_xp + D_x(uveta) + F_x \npartial_t v = -qhu -gpartial_yp + D_y(uveta) + F_y \npartial_t eta = -partial_x(uh) -partial_y(vh)\nendalign","category":"page"},{"location":"swm_equations/#Runge-Kutta-time-discretisation","page":"Tutorial","title":"Runge-Kutta time discretisation","text":"","category":"section"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"Let","category":"page"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"R(uveta) = beginpmatrix\n                qhv-gpartial_xp+F_x\n                -qhu-gpartial_yp+F_y\n                -partial_x(uh) -partial_y(vh)\n                endpmatrix","category":"page"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"be the non-dissipative right-hand side, i.e. excluding the dissipative terms mathbfD. Then we dicretise the time derivative with 4th order Runge-Kutta with mathbfk_n = (u_nv_neta_n) by","category":"page"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"beginalign\nmathbfd_1 = R(mathbfk_n)  \nmathbfd_2 = R(mathbfk_n + frac12Delta t mathbfd_1) \nmathbfd_3 = R(mathbfk_n + frac12Delta t mathbfd_2) \nmathbfd_4 = R(mathbfk_n + Delta t mathbfd_3) \nu_n+1^*v_n+1^*eta_n+1 = mathbfk_n+1 = mathbfk_n + frac16Delta t(mathbfd_1 + 2mathbfd_2 + 2mathbfd_3 + mathbfd_1)\nendalign","category":"page"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"and the dissipative terms are then added semi-implictly.","category":"page"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"beginalign\nu_n+1 = u_n+1^* + Delta t D_x(u_n+1^*v_n+1^*eta_n+1)  \nv_n+1 = v_n+1^* + Delta t D_y(u_n+1^*v_n+1^*eta_n+1)\nendalign","category":"page"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"Consequently, the dissipative terms only have to be evaluated once per time step, which reduces the computational cost of the right=hand side drastically. This is motivated as the Courant number C = sqrtgH_0 is restricted by gravity waves, which are caused by partial_tmathbfu = -gnablaeta and partial_teta = -H_0nabla cdot mathbfu. The other terms have longer time scales, and it is therefore sufficient to solve those with larger time steps. With this scheme, the shallow water model runs stable at C=1.\"","category":"page"},{"location":"swm_equations/#Strong-stability-preserving-Runge-Kutta-with-semi-implicit-continuity-equation","page":"Tutorial","title":"Strong stability preserving Runge-Kutta with semi-implicit continuity equation","text":"","category":"section"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"We split the right-hand side into the momentum equations and the continuity equation","category":"page"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"R_m(uveta) = beginpmatrix\n                qhv-gpartial_xp+F_x\n                -qhu-gpartial_yp+F_y\n                endpmatrix quad R_eta(uveta) = -partial_x(uh) -partial_y(vh)","category":"page"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"The 4-stage strong stability preserving Runge-Kutta scheme, with a semi-implicit treatment of the continuity equation then reads as","category":"page"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"beginalign\nmathbfu_1 = mathbfu_n + frac12 Delta t R_m(u_nv_neta_n) quad textthen\nquad eta_1 = eta_n + frac12 Delta t R_eta(u_1v_1eta_n) \nmathbfu_2 = mathbfu_1 + frac12 Delta t R_m(u_1v_1eta_1) quad textthen\nquad eta_2 = eta_1 + frac12 Delta t R_eta(u_2v_2eta_1)  \nmathbfu_3 = frac23mathbfu_n + frac13mathbfu_2 + frac16 Delta t R_m(u_2v_2eta_2) quad textthen\nquad eta_3 = frac23eta_n + frac13eta_2 + frac16 Delta t R_eta(u_3v_3eta_2) \nmathbfu_n+1 = mathbfu_3 + frac12 Delta t R_m(u_3v_3eta_3) quad textthen\nquad eta_n+1 = eta_3 + frac12 Delta t R_eta(u_n+1v_n+1eta_3)\nendalign","category":"page"},{"location":"swm_equations/#Splitting-the-continuity-equation","page":"Tutorial","title":"Splitting the continuity equation","text":"","category":"section"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"From","category":"page"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"partial_t = -partial_x(uh) - partial_y(vh)","category":"page"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"swm_equations/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [ShallowWaters]","category":"page"},{"location":"reference/#ShallowWaters.ArakawaHsuVars","page":"Reference","title":"ShallowWaters.ArakawaHsuVars","text":"ArakawaHsu variables collected in a struct.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ShallowWaters.ArakawaHsuVars-Union{Tuple{ShallowWaters.Grid}, Tuple{T}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.ArakawaHsuVars","text":"Generator function for ArakawaHsu VarCollection.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.BernoulliVars","page":"Reference","title":"ShallowWaters.BernoulliVars","text":"Bernoulli variables collected in a struct.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ShallowWaters.BernoulliVars-Union{Tuple{ShallowWaters.Grid}, Tuple{T}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.BernoulliVars","text":"Generator function for Bernoulli VarCollection.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.BottomdragVars","page":"Reference","title":"ShallowWaters.BottomdragVars","text":"Bottomdrag variables collected in a struct.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ShallowWaters.BottomdragVars-Union{Tuple{ShallowWaters.Grid}, Tuple{T}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.BottomdragVars","text":"Generator function for Bottomdrag VarCollection.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.Constants-Union{Tuple{Tprog}, Tuple{T}, Tuple{Parameter, ShallowWaters.Grid}} where {T<:AbstractFloat, Tprog<:AbstractFloat}","page":"Reference","title":"ShallowWaters.Constants","text":"Generator function for the mutable struct Constants.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.Grid-Union{Tuple{Parameter}, Tuple{Tprog}, Tuple{T}} where {T<:AbstractFloat, Tprog<:AbstractFloat}","page":"Reference","title":"ShallowWaters.Grid","text":"Generator function for the Grid struct.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.LaplaceVars","page":"Reference","title":"ShallowWaters.LaplaceVars","text":"Laplace variables collected in a struct.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ShallowWaters.LaplaceVars-Union{Tuple{ShallowWaters.Grid}, Tuple{T}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.LaplaceVars","text":"Generator function for Laplace VarCollection.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.NcFiles-Tuple{Nothing}","page":"Reference","title":"ShallowWaters.NcFiles","text":"Generator function for \"empty\" NcFiles struct.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.NcFiles-Tuple{ShallowWaters.Feedback, ShallowWaters.ModelSetup}","page":"Reference","title":"ShallowWaters.NcFiles","text":"Generator function for NcFiles struct, creating the underlying netCDF files.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.Parameter","page":"Reference","title":"ShallowWaters.Parameter","text":"Creates a Parameter struct with following options and default values\n\nT=Float32                 # number format\n\nTprog=T                   # number format for prognostic variables\nTcomm=Tprog               # number format for ghost-point copies\nTini=Tprog                # number format to reduce precision for initial conditions\n\n# DOMAIN RESOLUTION AND RATIO\nnx::Int=100                         # number of grid cells in x-direction\nLx::Real=4000e3                     # length of the domain in x-direction [m]\nL_ratio::Real=2                     # Domain aspect ratio of Lx/Ly\n\n# PHYSICAL CONSTANTS\ng::Real=0.1                         # gravitational acceleration [m/s]\nH::Real=500.                        # layer thickness at rest [m]\nρ::Real=1e3                         # water density [kg/m^3]\nϕ::Real=45.                         # central latitude of the domain (for coriolis) [°]\nω::Real=2π/(24*3600)                # Earth's angular frequency [s^-1]\nR::Real=6.371e6                     # Earth's radius [m]\n\n# SCALE\nscale::Real=2^6                     # multiplicative scale for the momentum equations u,v\nscale_sst::Real=2^15                # multiplicative scale for sst\n\n# WIND FORCING OPTIONS\nwind_forcing_x::String=\"shear\"      # \"channel\", \"double_gyre\", \"shear\",\"constant\" or \"none\"\nwind_forcing_y::String=\"constant\"   # \"channel\", \"double_gyre\", \"shear\",\"constant\" or \"none\"\nFx0::Real=0.12                      # wind stress strength [Pa] in x-direction\nFy0::Real=0.0                       # wind stress strength [Pa] in y-direction\nseasonal_wind_x::Bool=true          # Change the wind stress with a sine of frequency ωFx,ωFy\nseasonal_wind_y::Bool=false         # same for y-component\nωFx::Real=2                         # frequency [1/year] for x component\nωFy::Real=2                         # frequency [1/year] for y component\n\n# BOTTOM TOPOGRAPHY OPTIONS\ntopography::String=\"ridges\"         # \"ridge\", \"seamount\", \"flat\", \"ridges\", \"bathtub\"\ntopo_ridges_positions::Vector = [0.05,0.25,0.45,0.9]\ntopo_height::Real=100.               # height of seamount [m]\ntopo_width::Real=300e3              # horizontal scale [m] of the seamount\n\n# SURFACE RELAXATION\nsurface_relax::Bool=false           # yes?\nt_relax::Real=100.                  # time scale of the relaxation [days]\nη_refh::Real=5.                     # height difference [m] of the interface relaxation profile\nη_refw::Real=50e3                   # width [m] of the tangent used for the interface relaxation\n\n# SURFACE FORCING\nsurface_forcing::Bool=false         # yes?\nωFη::Real=1.0                       # frequency [1/year] for surfance forcing\nA::Real=3e-5                        # Amplitude [m/s]\nϕk::Real=ϕ                          # Central latitude of Kelvin wave pumping\nwk::Real=10e3                       # width [m] in y of Gaussian used for surface forcing\n\n# TIME STEPPING OPTIONS\ntime_scheme::String=\"SSPRK3\"        # Runge-Kutta (\"RK\") or strong-stability preserving RK\n                                    # \"SSPRK2\",\"SSPRK3\",\"4SSPRK3\"\nRKo::Int=4                          # Order of the RK time stepping scheme (2, 3 or 4)\nRKs::Int=3                          # Number of stages for SSPRK2\nRKn::Int=5                          # n^2 = s = Number of stages  for SSPRK3\ncfl::Real=4.0                       # CFL number (1.0 recommended for RK4, 0.6 for RK3)\nNdays::Real=200.0                   # number of days to integrate for\nnstep_diff::Int=1                   # diffusive part every nstep_diff time steps.\nnstep_advcor::Int=0                 # advection and coriolis update every nstep_advcor time steps.\n                                    # 0 means it is included in every RK4 substep\n\n# BOUNDARY CONDITION OPTIONS\nbc::String=\"periodic\"               # \"periodic\" or anything else for nonperiodic\nα::Real=2.                          # lateral boundary condition parameter\n                                    # 0 free-slip, 0<α<2 partial-slip, 2 no-slip\n\n# MOMENTUM ADVECTION OPTIONS\nadv_scheme::String=\"ArakawaHsu\"     # \"Sadourny\" or \"ArakawaHsu\"\ndynamics::String=\"nonlinear\"        # \"linear\" or \"nonlinear\"\n\n# BOTTOM FRICTION OPTIONS\nbottom_drag::String=\"none\"          # \"linear\", \"quadratic\" or \"none\"\ncD::Real=1e-5                       # bottom drag coefficient [dimensionless] for quadratic\nτD::Real=300.                       # bottom drag coefficient [days] for linear\n\n# DIFFUSION OPTIONS\ndiffusion::String=\"constant\"        # \"Smagorinsky\" or \"constant\", biharmonic in both cases\nνB::Real=500.0                      # [m^2/s] scaling constant for constant biharmonic diffusion\ncSmag::Real=0.15                    # Smagorinsky coefficient [dimensionless]\n\n# TRACER ADVECTION\ntracer_advection::Bool=true         # yes?\ntracer_relaxation::Bool=true        # yes?\ntracer_consumption::Bool=false      # yes?\nsst_initial::String=\"waves\"         # \"west\", \"south\", \"linear\", \"waves\",\"rect\", \"flat\" or \"restart\"\nsst_rect_coords::Array{Float64,1}=[0.,0.15,0.,1.0]\n                                    # (x0,x1,y0,y1) are the size of the rectangle in [0,1]\nUadv::Real=0.2                      # Velocity scale [m/s] for tracer advection\nSSTmax::Real=1.                     # tracer (sea surface temperature) max for initial conditions\nSSTmin::Real=-1.                    # tracer (sea surface temperature) min for initial conditions\nτSST::Real=100                      # tracer restoring time scale [days]\njSST::Real=365                      # tracer consumption [days]\nSSTw::Real=5e5                      # width [m] of the tangent used for the IC and interface relaxation\nSSTϕ::Real=0.5                      # latitude/longitude fraction ∈ [0,1] of sst edge\nSSTwaves_ny::Real=4                 # wave crests/troughs in y\nSSTwaves_nx::Real=SSTwaves_ny*L_ratio  # wave crests/troughs in x\nSSTwaves_p::Real=1/2                # power for rectangles (p<1)/smootheness(p>=1) of waves\n\n# OUTPUT OPTIONS\noutput::Bool=false                  # netcdf output?\noutput_vars::Array{String,1}=[\"u\",\"v\",\"η\",\"sst\"]  # which variables to output? \"du\",\"dv\",\"dη\" also allowed\noutput_dt::Real=24                  # output time step [hours]\noutpath::String=pwd()               # path to output folder\ncompression_level::Int=3            # compression level\n\n# INITIAL CONDITIONS\ninitial_cond::String=\"rest\"         # \"rest\" or \"ncfile\" for restart from file\ninitpath::String=outpath            # folder where to pick the restart files from\ninit_run_id::Int=0                  # run id for restart from run number\ninit_starti::Int=-1                 # timestep to start from (-1 meaning last)\nget_id_mode::String=\"continue\"      # How to determine the run id: \"continue\" or \"fill\"\nrun_id::Int=-1                      # Output with a specific run id\ninit_interpolation::Bool=true       # Interpolate the initial conditions in case grids don't match?\n\n\n\n\n\n","category":"type"},{"location":"reference/#ShallowWaters.PrognosticVars","page":"Reference","title":"ShallowWaters.PrognosticVars","text":"P = ProgVars{T}(u,v,η,sst)\n\nStruct containing the prognostic variables u,v,η and sst.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ShallowWaters.PrognosticVars-Union{Tuple{ShallowWaters.Grid}, Tuple{T}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.PrognosticVars","text":"Zero generator function for Grid G as argument.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.RungeKuttaVars","page":"Reference","title":"ShallowWaters.RungeKuttaVars","text":"Runge Kutta time stepping scheme diagnostic cariables collected in a struct.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ShallowWaters.RungeKuttaVars-Union{Tuple{ShallowWaters.Grid}, Tuple{T}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.RungeKuttaVars","text":"Generator function for RungeKutta VarCollection.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.SSPRK3coeff","page":"Reference","title":"ShallowWaters.SSPRK3coeff","text":"Coefficients for strong stability-preserving Runge-Kutta 3rd order. From: KETCHESON, LOĆZI, AND PARSANI, 2014. INTERNAL ERROR PROPAGATION IN EXPLICIT RUNGE–KUTTA METHODS,  SIAM J NUMER ANAL 52/5. DOI:10.1137/130936245\n\n\n\n\n\n","category":"type"},{"location":"reference/#ShallowWaters.SSPRK3coeff-Union{Tuple{T}, Tuple{Parameter, T}} where T","page":"Reference","title":"ShallowWaters.SSPRK3coeff","text":"Generator function for a SSPRK3coeff struct.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.SemiLagrangeVars","page":"Reference","title":"ShallowWaters.SemiLagrangeVars","text":"SemiLagrange variables collected in a struct.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ShallowWaters.SemiLagrangeVars-Union{Tuple{ShallowWaters.Grid}, Tuple{T}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.SemiLagrangeVars","text":"Generator function for SemiLagrange VarCollection.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.SmagorinskyVars","page":"Reference","title":"ShallowWaters.SmagorinskyVars","text":"Smagorinsky variables collected in a struct.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ShallowWaters.SmagorinskyVars-Union{Tuple{ShallowWaters.Grid}, Tuple{T}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.SmagorinskyVars","text":"Generator function for Smagorinsky VarCollection.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.TendencyVars","page":"Reference","title":"ShallowWaters.TendencyVars","text":"Tendencies collected in a struct.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ShallowWaters.TendencyVars-Union{Tuple{ShallowWaters.Grid}, Tuple{T}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.TendencyVars","text":"Generator function for Tendencies VarCollection.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.VolumeFluxVars","page":"Reference","title":"ShallowWaters.VolumeFluxVars","text":"VolumeFluxes collected in a struct.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ShallowWaters.VolumeFluxVars-Union{Tuple{ShallowWaters.Grid}, Tuple{T}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.VolumeFluxVars","text":"Generator function for VolumeFluxes VarCollection.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.VorticityVars","page":"Reference","title":"ShallowWaters.VorticityVars","text":"Vorticity variables collected in a struct.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ShallowWaters.VorticityVars-Union{Tuple{ShallowWaters.Grid}, Tuple{T}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.VorticityVars","text":"Generator function for Vorticity VarCollection.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.convert-Union{Tuple{N}, Tuple{T2}, Tuple{T1}, Tuple{Array{T2, N}, Array{T1, N}}} where {T1, T2, N}","page":"Reference","title":"Base.convert","text":"Convert function for two arrays, X1, X2, in case their eltypes differ. Convert every element from X1 and store it in X2.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.convert-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, Array{T, N}}} where {T, N}","page":"Reference","title":"Base.convert","text":"Convert function for two arrays, X1, X2, in case their eltypes are identical. Just pass X1, such that X2 is pointed to the same place in memory.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.AHα!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.AHα!","text":"Linear combination α of potential voriticity q according to the energy and enstrophy conserving scheme of Arakawa and Hsu, 1990\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.AHβ!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.AHβ!","text":"Linear combination δ of potential voriticity q according to the energy and enstrophy conserving scheme of Arakawa and Hsu, 1990 \n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.AHγ!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.AHγ!","text":"Linear combination γ of potential voriticity q according to the energy and enstrophy conserving scheme of Arakawa and Hsu, 1990 \n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.AHδ!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.AHδ!","text":"Linear combination β of potential voriticity q according to the energy and enstrophy conserving scheme of Arakawa and Hsu, 1990 \n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.ChannelWind-Union{Tuple{T}, Tuple{Type{T}, Parameter, ShallowWaters.Grid}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.ChannelWind","text":"Returns the constant forcing matrices Fx,Fy that vary only meriodionally/zonally as a cosine with strongest forcing in the middle and vanishing forcing at boundaries.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.ConstantWind-Union{Tuple{T}, Tuple{Type{T}, Parameter, ShallowWaters.Grid}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.ConstantWind","text":"Returns constant in in space forcing matrices Fx,Fy.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.DoubleGyreWind-Union{Tuple{T}, Tuple{Type{T}, Parameter, ShallowWaters.Grid}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.DoubleGyreWind","text":"Returns the constant forcing matrices Fx,Fy that vary only meriodionally/zonally with a superposition of sin & cos for a double gyre circulation. See Cooper&Zanna 2015 or Kloewer et al 2018.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.FlatBottom-Union{Tuple{T}, Tuple{Type{T}, Parameter, ShallowWaters.Grid}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.FlatBottom","text":"Returns a matrix of constant water depth H.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.Ftime-Union{Tuple{T}, Tuple{Type{T}, Int64, Real}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.Ftime","text":"Time evolution of forcing.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.InterfaceRelaxation-Union{Tuple{T}, Tuple{Type{T}, Parameter, ShallowWaters.Grid}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.InterfaceRelaxation","text":"Returns a reference state for Newtonian cooling/surface relaxation shaped as a hyperbolic tangent to force the continuity equation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.Ix!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.Ix!","text":"Linear interpolation of a variable u in the x-direction. m,n = size(ux) must be m+1,n = size(u).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.Ixy!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.Ixy!","text":"Bilinear interpolation a variable u in x and y-direction. m,n = size(uxy) must be m+1,n+1 = size(u). \n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.Iy!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.Iy!","text":"Linear interpolation a variable u in the y-direction. m,n = size(uy) must be m,n+1 = size(u).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.KelvinPump-Union{Tuple{T}, Tuple{Type{T}, Parameter, ShallowWaters.Grid}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.KelvinPump","text":"Returns Kelvin wave pumping forcing of the continuity equation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.NoWind-Union{Tuple{T}, Tuple{Type{T}, Parameter, ShallowWaters.Grid}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.NoWind","text":"Returns constant in in space forcing matrices Fx,Fy.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.PV!-Tuple{ShallowWaters.DiagnosticVars, ShallowWaters.ModelSetup}","page":"Reference","title":"ShallowWaters.PV!","text":"Potential vorticity calculated as q = (f + ∂v/∂x - ∂u/∂y)/h.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.PV_ArakawaHsu!-Tuple{ShallowWaters.DiagnosticVars}","page":"Reference","title":"ShallowWaters.PV_ArakawaHsu!","text":"Advection of potential vorticity qhv,qhu as in Arakawa and Hsu, 1990 Energy and enstrophy conserving (in the limit of non-divergent mass flux) scheme with τ = 0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.PV_Sadourny!-Tuple{ShallowWaters.DiagnosticVars}","page":"Reference","title":"ShallowWaters.PV_Sadourny!","text":"Advection of potential vorticity qhv,qhu as in Sadourny, 1975 enstrophy conserving scheme.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.PVadvection!-Tuple{ShallowWaters.DiagnosticVars, ShallowWaters.ModelSetup}","page":"Reference","title":"ShallowWaters.PVadvection!","text":"Transit function to call the specified advection scheme.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.Ridge-Union{Tuple{T}, Tuple{Type{T}, Parameter, ShallowWaters.Grid}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.Ridge","text":"Returns a matrix of water depth for the whole domain that contains a meridional Gaussian ridge in the middle. Water depth, heigth and width of the ridge are adjusted with the constants waterdepth, topofeatheight and topofeat_width.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.Ridges-Union{Tuple{T}, Tuple{Type{T}, Parameter, ShallowWaters.Grid}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.Ridges","text":"Same as Ridge() but for n ridges at various x positions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.Seamount-Union{Tuple{T}, Tuple{Type{T}, Parameter, ShallowWaters.Grid}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.Seamount","text":"Returns a matrix of water depth for the whole domain that contains a Gaussian seamount in the middle. Water depth, heigth and width of the seamount are adjusted with the constants H, topofeatheight and topofeatwidth.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.ShearWind-Union{Tuple{T}, Tuple{Type{T}, Parameter, ShallowWaters.Grid}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.ShearWind","text":"Returns the constant forcing matrices Fx,Fy that vary only meriodionally/zonally as a hyperbolic tangent with strongest shear in the middle.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.UVfluxes!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, ShallowWaters.DiagnosticVars, ShallowWaters.ModelSetup}","page":"Reference","title":"ShallowWaters.UVfluxes!","text":"Calculate the mass/volume fluxes U,V from u,v,η.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.Uflux!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, Int64, T}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.Uflux!","text":"Zonal mass flux U = uh.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.Vflux!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, T}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.Vflux!","text":"Meridional mass flux V = vh.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.add_drag_diff_tendencies!-Union{Tuple{Tprog}, Tuple{T}, Tuple{Matrix{Tprog}, Matrix{Tprog}, ShallowWaters.DiagnosticVars{T, Tprog}, ShallowWaters.ModelSetup{T, Tprog}}} where {T, Tprog}","page":"Reference","title":"ShallowWaters.add_drag_diff_tendencies!","text":"Update u with bottom friction tendency (Bu,Bv) and biharmonic viscosity.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.add_halo-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}, Matrix{T}, ShallowWaters.ModelSetup}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.add_halo","text":"Extends the matrices u,v,η,sst with a halo of ghost points for boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.adv_sst!-Tuple{AbstractMatrix, ShallowWaters.DiagnosticVars, ShallowWaters.ModelSetup}","page":"Reference","title":"ShallowWaters.adv_sst!","text":"Advection of sst/tracer based on the departure points xd,yd via bilinear interpolation. Departure points are clipped/wrapped to remain within the domain. Boundary conditions either periodic (wrap around behaviour) or no-flux (no gradient via clipping). Once the respective 4 surrounding grid points are found do bilinear interpolation on the unit square.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.advection_coriolis!-Union{Tuple{Tprog}, Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}, ShallowWaters.DiagnosticVars{T, Tprog}, ShallowWaters.ModelSetup{T, Tprog}}} where {T, Tprog}","page":"Reference","title":"ShallowWaters.advection_coriolis!","text":"Update advective and Coriolis tendencies.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.axb!-Union{Tuple{T}, Tuple{Matrix{T}, Real, Matrix{T}}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.axb!","text":"Add to a x multiplied with b. a += x*b \n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.backtraj!-Union{Tuple{T}, Tuple{Matrix{T}, T, Matrix{T}, Int64}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.backtraj!","text":"Solves the trajectory equation for a given time step dt and the velocity uv (this can be u or v). One function for three cases\n\n(i) u is interpolated from u-grid with halo onto T-grid (ii) v is interpolated from v-grid with halo onto T-grid (iii) u or v already on the T-grid: All matrices have same size.\n\nUses relative grid nodes in the departure points rd, such that actually solved is rd = 0 - dt*uv. The indices i,j of rd determine the arrival grid point.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.bernoulli!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}, Matrix{T}, T, Int64, T}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.bernoulli!","text":"Bernoulli potential p = 1/2*(u² + v²) + gη.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.bilin-Union{Tuple{T}, NTuple{6, T}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.bilin","text":"Bilinear interpolation on (x,y) in the unit square [0,1]x[0,1]. The values at the corners are f00 = f(0,0), f01 = f(0,1), etc.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.bottom_drag!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, ShallowWaters.DiagnosticVars, ShallowWaters.ModelSetup}","page":"Reference","title":"ShallowWaters.bottom_drag!","text":"Transit function to call the specified bottom drag function.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.bottom_drag_linear!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, ShallowWaters.DiagnosticVars, ShallowWaters.ModelSetup}","page":"Reference","title":"ShallowWaters.bottom_drag_linear!","text":"Linear bottom drag computed as rB*(u,v). rB is negative and contains the grid spacing Δ as gradient operators are dimensionless.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.bottom_drag_quadratic!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, ShallowWaters.DiagnosticVars, ShallowWaters.ModelSetup}","page":"Reference","title":"ShallowWaters.bottom_drag_quadratic!","text":"Quadratic bottom drag Bu,Bv = cD/h * | uv | * uv\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.caxb!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, T, Matrix{T}}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.caxb!","text":"c equals add a to x multiplied with b. c = a + x*b \n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.clip-Union{Tuple{T}, Tuple{Int64, Int64, T, Int64, Int64, Int64}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.clip","text":"Clips the relative lower-left corner index xyi (for both x or y indices) to remain within the domain. ij is the index of the underlying matrix. xy is the actual coordinate, mn (m or n) the size of the domain, and h1,h2 are the halo sizes (left/south and right/north).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.continuity!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, ShallowWaters.DiagnosticVars, ShallowWaters.ModelSetup, Int64}","page":"Reference","title":"ShallowWaters.continuity!","text":"Transit function to call the specified continuity function.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.continuity_forcing!-Union{Tuple{Tprog}, Tuple{T}, Tuple{ShallowWaters.DiagnosticVars{T, Tprog}, ShallowWaters.ModelSetup{T, Tprog}, Int64}} where {T, Tprog}","page":"Reference","title":"ShallowWaters.continuity_forcing!","text":"Continuity equation's right-hand side with time&space dependent forcing.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.continuity_itself!-Union{Tuple{Tprog}, Tuple{T}, Tuple{ShallowWaters.DiagnosticVars{T, Tprog}, ShallowWaters.ModelSetup{T, Tprog}, Int64}} where {T, Tprog}","page":"Reference","title":"ShallowWaters.continuity_itself!","text":"Continuity equation's right-hand side -∂x(uh) - ∂y(vh) without forcing.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.continuity_surf_relax!-Union{Tuple{Tprog}, Tuple{T}, Tuple{Matrix{T}, ShallowWaters.DiagnosticVars{T, Tprog}, ShallowWaters.ModelSetup{T, Tprog}, Int64}} where {T, Tprog}","page":"Reference","title":"ShallowWaters.continuity_surf_relax!","text":"Continuity equation's right-hand side with surface relaxation -∂x(uh) - ∂y(vh) + γ*(η_ref - η).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.coriolis_at_lat-Tuple{Real, Real}","page":"Reference","title":"ShallowWaters.coriolis_at_lat","text":"Coriolis parameter f [1/s] at latitude ϕ [°] given Earth's rotation ω [1/s].\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.countnans-Tuple{AbstractArray}","page":"Reference","title":"ShallowWaters.countnans","text":"Returns the number of NaNs in an array.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.cxab!-Union{Tuple{T}, Tuple{Matrix{T}, Real, Matrix{T}, Matrix{T}}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.cxab!","text":"c equals add x multiplied to a plus b. c = x*(a+b) \n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.cxayb!-Union{Tuple{T}, Tuple{Matrix{T}, Real, Matrix{T}, Real, Matrix{T}}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.cxayb!","text":"c = xa + yb\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.dambmc!-Union{Tuple{T}, NTuple{4, Matrix{T}}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.dambmc!","text":"d equals add a minus b minus c. c = (a - b) - c.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.departure!-Tuple{AbstractMatrix, AbstractMatrix, ShallowWaters.DiagnosticVars, ShallowWaters.ModelSetup}","page":"Reference","title":"ShallowWaters.departure!","text":"Computes the departure point for semi-Lagrangian advection following Diamantakis, 2014. u,v are assumed to be the time averaged velocities over the previous advection time step. (Presumably need to be changed to 2nd order extrapolation in case the tracer is not passive)\n\nUses fixed-point iteration once to find the departure point.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.diffusion!-Tuple{AbstractMatrix, AbstractMatrix, ShallowWaters.DiagnosticVars, ShallowWaters.ModelSetup}","page":"Reference","title":"ShallowWaters.diffusion!","text":"Transit function to call the specified diffusion scheme.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.diffusion_constant!-Tuple{AbstractMatrix, AbstractMatrix, ShallowWaters.DiagnosticVars, ShallowWaters.ModelSetup}","page":"Reference","title":"ShallowWaters.diffusion_constant!","text":"Biharmonic diffusion operator with constant viscosity coefficient Viscosity = ν∇⁴ ⃗u. Although constant, the coefficient is actually inside Viscosity = ∇⋅ν∇∇² ⃗u.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.diffusion_smagorinsky!-Tuple{AbstractMatrix, AbstractMatrix, ShallowWaters.DiagnosticVars, ShallowWaters.ModelSetup}","page":"Reference","title":"ShallowWaters.diffusion_smagorinsky!","text":"Smagorinsky-like biharmonic viscosity Viscosity = ∇ ⋅ (cSmag Δ⁴ |D| ∇∇² ⃗u) The Δ⁴-scaling is omitted as gradient operators are dimensionless.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.duration_estimate-Tuple{ShallowWaters.Feedback, ShallowWaters.ModelSetup}","page":"Reference","title":"ShallowWaters.duration_estimate","text":"Estimates the total time the model integration will take.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.dxaybzc!-Union{Tuple{T}, Tuple{Matrix{T}, Real, Matrix{T}, Real, Matrix{T}, Real, Matrix{T}}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.dxaybzc!","text":"d = xa + yb + z*c\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.feedback!-Tuple{ShallowWaters.PrognosticVars, ShallowWaters.Feedback, ShallowWaters.ModelSetup}","page":"Reference","title":"ShallowWaters.feedback!","text":"Feedback function that calls duration estimate, nan_detection and progress.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.feedback_end!-Tuple{ShallowWaters.Feedback}","page":"Reference","title":"ShallowWaters.feedback_end!","text":"Finalises the progress txt file.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.feedback_init-Tuple{ShallowWaters.ModelSetup}","page":"Reference","title":"ShallowWaters.feedback_init","text":"Initialises the progress txt file.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.fu!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, Int64}","page":"Reference","title":"ShallowWaters.fu!","text":"Coriolis term f*u. \n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.fv!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, Int64}","page":"Reference","title":"ShallowWaters.fv!","text":"Coriolis term f*v. \n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.gap-Tuple{Vector{Int64}}","page":"Reference","title":"ShallowWaters.gap","text":"Finds the first gap in a list of integers.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.get_run_id_path-Tuple{ShallowWaters.ModelSetup}","page":"Reference","title":"ShallowWaters.get_run_id_path","text":"Checks output folders to determine a 4-digit run id number.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.ghost_points!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, ShallowWaters.ModelSetup}","page":"Reference","title":"ShallowWaters.ghost_points!","text":"Decide on boundary condition P.bc which ghost point function to execute.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.ghost_points_sst!-Tuple{AbstractMatrix, ShallowWaters.ModelSetup}","page":"Reference","title":"ShallowWaters.ghost_points_sst!","text":"Decide on boundary condition P.bc which ghost point function to execute.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.ghost_points_sst_nonperiodic!-Tuple{AbstractMatrix, Int64, Int64}","page":"Reference","title":"ShallowWaters.ghost_points_sst_nonperiodic!","text":"Copy ghost points for η from inside to the halo in the nonperiodic case. \n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.ghost_points_sst_periodic!-Union{Tuple{T}, Tuple{Tcomm}, Tuple{Type{Tcomm}, Matrix{T}, Int64, Int64}} where {Tcomm, T}","page":"Reference","title":"ShallowWaters.ghost_points_sst_periodic!","text":"Copy ghost points for η from inside to the halo in the periodic case. \n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.ghost_points_u_nonperiodic!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, T}} where T","page":"Reference","title":"ShallowWaters.ghost_points_u_nonperiodic!","text":"Copy ghost points for u from inside to the halo in the nonperiodic case. \n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.ghost_points_u_periodic!-Union{Tuple{T}, Tuple{Tcomm}, Tuple{Type{Tcomm}, AbstractMatrix{T}, T}} where {Tcomm, T}","page":"Reference","title":"ShallowWaters.ghost_points_u_periodic!","text":"Copy ghost points for u from inside to the halo in the periodic case. \n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.ghost_points_uv!-Tuple{AbstractMatrix, AbstractMatrix, ShallowWaters.ModelSetup}","page":"Reference","title":"ShallowWaters.ghost_points_uv!","text":"Decide on boundary condition P.bc which ghost point function to execute.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.ghost_points_v_nonperiodic!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, T}} where T","page":"Reference","title":"ShallowWaters.ghost_points_v_nonperiodic!","text":"Copy ghost points for v from inside to the halo in the nonperiodic case. \n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.ghost_points_v_periodic!-Union{Tuple{T}, Tuple{Tcomm}, Tuple{Type{Tcomm}, Matrix{T}}} where {Tcomm, T}","page":"Reference","title":"ShallowWaters.ghost_points_v_periodic!","text":"Copy ghost points for v from inside to the halo in the periodic case. \n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.ghost_points_η!-Tuple{AbstractMatrix, ShallowWaters.ModelSetup}","page":"Reference","title":"ShallowWaters.ghost_points_η!","text":"Decide on boundary condition P.bc which ghost point function to execute.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.ghost_points_η_nonperiodic!-Tuple{AbstractMatrix}","page":"Reference","title":"ShallowWaters.ghost_points_η_nonperiodic!","text":"Copy ghost points for η from inside to the halo in the nonperiodic case. \n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.ghost_points_η_periodic!-Union{Tuple{T}, Tuple{Tcomm}, Tuple{Type{Tcomm}, Matrix{T}}} where {Tcomm, T}","page":"Reference","title":"ShallowWaters.ghost_points_η_periodic!","text":"Copy ghost points for η from inside to the halo in the periodic case. \n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.interp_uv!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, ShallowWaters.ModelSetup}","page":"Reference","title":"ShallowWaters.interp_uv!","text":"Interpolates the matrix uv into the matrix uvi, where xx, yy specify the coordinates as indices (including fraction. Interpolation only onto the inner entries of uvi. (They will be copied back later via the ghostpoint function). Two cases     (i) u velocities: from u-grid with halo to T-grid     (ii) v velocities: from v-grid with halo to T-grid.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.m_per_lat-Tuple{Real}","page":"Reference","title":"ShallowWaters.m_per_lat","text":"Meter per 1 degree of latitude (or longitude at the equator).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.meshgrid-Tuple{AbstractVector, AbstractVector}","page":"Reference","title":"ShallowWaters.meshgrid","text":"Similar to the numpy meshgrid function: repeats x length(y)-times and vice versa. Returns two matrices xx,yy of same shape so that each row of xx is x and each column of yy is y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.momentum_u!-Union{Tuple{Tprog}, Tuple{T}, Tuple{ShallowWaters.DiagnosticVars{T, Tprog}, ShallowWaters.ModelSetup, Int64}} where {T, Tprog}","page":"Reference","title":"ShallowWaters.momentum_u!","text":"Sum up the tendencies of the non-diffusive right-hand side for the u-component.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.momentum_v!-Union{Tuple{Tprog}, Tuple{T}, Tuple{ShallowWaters.DiagnosticVars{T, Tprog}, ShallowWaters.ModelSetup, Int64}} where {T, Tprog}","page":"Reference","title":"ShallowWaters.momentum_v!","text":"Sum up the tendencies of the non-diffusive right-hand side for the v-component.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.nan_detection!-Tuple{ShallowWaters.PrognosticVars, ShallowWaters.Feedback}","page":"Reference","title":"ShallowWaters.nan_detection!","text":"Returns a boolean whether the prognostic variables contains a NaN.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.nc_create-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, String, String, String, String, Parameter}} where T<:Real","page":"Reference","title":"ShallowWaters.nc_create","text":"Creates a netCDF file based on grid vectors x,y the variable name, its path, unit and long_name.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.no_bottom_drag!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, ShallowWaters.DiagnosticVars, ShallowWaters.ModelSetup}","page":"Reference","title":"ShallowWaters.no_bottom_drag!","text":"No bottom drag.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.output_close!-Tuple{ShallowWaters.NcFiles, ShallowWaters.Feedback, ShallowWaters.ModelSetup}","page":"Reference","title":"ShallowWaters.output_close!","text":"Closes netCDF and progress.txt files.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.preallocate-Union{Tuple{Tprog}, Tuple{T}, Tuple{Type{T}, Type{Tprog}, ShallowWaters.Grid}} where {T<:AbstractFloat, Tprog<:AbstractFloat}","page":"Reference","title":"ShallowWaters.preallocate","text":"Preallocate the diagnostic variables and return them as matrices in structs.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.progress!-Tuple{ShallowWaters.Feedback}","page":"Reference","title":"ShallowWaters.progress!","text":"Converts time step into percent for feedback.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.readable_secs-Tuple{Real}","page":"Reference","title":"ShallowWaters.readable_secs","text":"Returns a human readable string representing seconds in terms of days, hours, minutes or seconds.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.remove_halo-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}, Matrix{T}, ShallowWaters.ModelSetup}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.remove_halo","text":"Cut off the halo from the prognostic variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.rhs!-Union{Tuple{Tprog}, Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}, ShallowWaters.DiagnosticVars{T, Tprog}, ShallowWaters.ModelSetup{T, Tprog}, Int64}} where {T, Tprog}","page":"Reference","title":"ShallowWaters.rhs!","text":"Transit function to call either the rhslinear or the rhsnonlinear.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.rhs_linear!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, ShallowWaters.DiagnosticVars, ShallowWaters.ModelSetup, Int64}","page":"Reference","title":"ShallowWaters.rhs_linear!","text":"Tendencies du,dv of\n\n    ∂u/∂t = fv - g∂η/∂x + Fx\n    ∂v/∂t = -fu - g∂η/∂y + Fy\n\nthe linear shallow water equations.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.rhs_nonlinear!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, ShallowWaters.DiagnosticVars, ShallowWaters.ModelSetup, Int64}","page":"Reference","title":"ShallowWaters.rhs_nonlinear!","text":"Tendencies du,dv of\n\n    ∂u/∂t = qhv - ∂(1/2*(u²+v²) + gη)/∂x + Fx\n    ∂v/∂t = -qhu - ∂(1/2*(u²+v²) + gη)/∂y + Fy\n\nthe nonlinear shallow water equations.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.run_model-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.run_model","text":"u,v,η,sst = run_model()\n\nruns ShallowWaters with default parameters as defined in src/DefaultParameters.jl\n\nExamples\n\njulia> u,v,η,sst = run_model(Float64,nx=200,output=true)\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.smagorinsky_coeff!-Tuple{ShallowWaters.DiagnosticVars, ShallowWaters.ModelSetup}","page":"Reference","title":"ShallowWaters.smagorinsky_coeff!","text":"νSmag = cSmag * |D|, where deformation rate |D| = √((∂u/∂x - ∂v/∂y)^2 + (∂u/∂y + ∂v/∂x)^2). The grid spacing Δ is omitted here as the operators are dimensionless.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.speed!-NTuple{4, AbstractMatrix}","page":"Reference","title":"ShallowWaters.speed!","text":"Squared velocities u²,v².\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.stress_tensor!-Tuple{AbstractMatrix, AbstractMatrix, ShallowWaters.DiagnosticVars}","page":"Reference","title":"ShallowWaters.stress_tensor!","text":"Biharmonic stress tensor ∇∇²(u,v) = (∂/∂x(∇²u), ∂/∂y(∇²u); ∂/∂x(∇²v), ∂/∂y(∇²v))\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.thickness!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}","page":"Reference","title":"ShallowWaters.thickness!","text":"Layer thickness h obtained by adding sea surface height η to bottom height H.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.time_integration-Union{Tuple{Tprog}, Tuple{T}, Tuple{ShallowWaters.PrognosticVars{Tprog}, ShallowWaters.DiagnosticVars{T, Tprog}, ShallowWaters.ModelSetup{T, Tprog}}} where {T<:AbstractFloat, Tprog<:AbstractFloat}","page":"Reference","title":"ShallowWaters.time_integration","text":"Integrates ShallowWaters forward in time.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.tracer_relax_consumption!-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, ShallowWaters.ModelSetup}","page":"Reference","title":"ShallowWaters.tracer_relax_consumption!","text":"Tracer relaxation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.viscous_tensor_constant!-Tuple{ShallowWaters.DiagnosticVars, ShallowWaters.ModelSetup}","page":"Reference","title":"ShallowWaters.viscous_tensor_constant!","text":"Biharmonic stress tensor times constant viscosity coefficient νB * ∇∇² ⃗u = (S11, S12; S21, S22)\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.viscous_tensor_smagorinsky!-Tuple{ShallowWaters.DiagnosticVars}","page":"Reference","title":"ShallowWaters.viscous_tensor_smagorinsky!","text":"Biharmonic stress tensor times Smagorinsky coefficient νSmag * ∇∇² ⃗u = (S11, S12; S21, S22).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.waves-Tuple{AbstractMatrix, AbstractMatrix, Real, Real, Real}","page":"Reference","title":"ShallowWaters.waves","text":"Create a wave-checkerboard pattern over xx,yy like a nx x ny checkerboard. p is the power to which the waves are raised. Choose p<1 for rectangles, and p > 1 for more smootheness.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.wrap-Union{Tuple{T}, Tuple{Int64, Int64, T, Int64, Int64, Int64}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.wrap","text":"Clips the relative lower-left corner index xyi (for both x or y indices) to remain within the domain. ij is the index of the underlying matrix. xy is the actual coordinate, mn (m or n) the size of the domain, and h is the halo size.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.yy_q-Tuple{String, AbstractVector, AbstractVector}","page":"Reference","title":"ShallowWaters.yy_q","text":"Helper function to create yy_q based on the boundary condition bc.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.β_at_lat-Tuple{Real, Real, Real}","page":"Reference","title":"ShallowWaters.β_at_lat","text":"Coriolis parameter's derivative β wrt latitude [(ms)^-1] at latitude ϕ, given Earth's rotation ω [1/s] and radius R [m].\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.∂x!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.∂x!","text":"Calculates the 2nd order centred gradient in x-direction on any grid (u,v,T or q). The size of dudx must be m-1,n compared to m,n = size(u)\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.∂x-Union{Tuple{T}, Tuple{Matrix{T}, Real}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.∂x","text":"∂x is the 2nd order centred Gradient-operator ∂/∂x with grid spacing Δ (default 1).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.∂y!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.∂y!","text":"Calculates the 2nd order centred gradient in y-direction on any grid (u,v,T or q). The size of dudy must be m,n-1 compared to m,n = size(u).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.∂y-Union{Tuple{Matrix{T}}, Tuple{T}, Tuple{Matrix{T}, Real}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.∂y","text":"∂y is the 2nd order centred Gradient-operator ∂/∂y with grid spacing Δ (default 1).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.∇²!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.∇²!","text":"∇² is the 2nd order centred Laplace-operator ∂/∂x^2 + ∂/∂y^2. The 1/Δ²-factor is omitted and moved into the viscosity coefficient.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ShallowWaters.∇²-Union{Tuple{Matrix{T}}, Tuple{T}, Tuple{Matrix{T}, Real}} where T<:AbstractFloat","page":"Reference","title":"ShallowWaters.∇²","text":"∇² is the 2nd order centred Laplace-operator ∂/∂x^2 + ∂/∂y^2 with grid spacing Δ (default 1).\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaters.jl-A-type-flexible-16-bit-shallow-water-model","page":"Introduction","title":"ShallowWaters.jl - A type-flexible 16-bit shallow water model","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: CI) (Image: DOI) (Image: sst)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A shallow water model with a focus on type-flexibility and 16-bit number formats. ShallowWaters allows for Float64/32/16,  Posit32/16/8, BFloat16,  LogFixPoint16, Sonum16,  Float32/16 & BFloat16 with stochastic rounding and in  general every number format with arithmetics and conversions implemented. ShallowWaters also allows for mixed-precision and reduced precision communication.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"ShallowWaters uses an energy and enstrophy conserving advection scheme and a Smagorinsky-like biharmonic diffusion operator.  Tracer advection is implemented with a semi-Lagrangian advection scheme. Strong stability-preserving Runge-Kutta schemes of various orders and stages are used with a semi-implicit treatment of the continuity equation. Boundary conditions are either  periodic (only in x direction) or non-periodic super-slip, free-slip, partial-slip, or no-slip. Output via NetCDF.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Please feel free to raise an issue if you discover bugs or have an idea how to improve ShallowWaters.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Requires: Julia 1.2 or higher","category":"page"},{"location":"#How-to-use","page":"Introduction","title":"How to use","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"RunModel initialises the model, preallocates memory and starts the time integration. You find the options and default parameters in src/DefaultParameters.jl (or by typing ?Parameter).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"help?> Parameter\nsearch: Parameter\n\n  Creates a Parameter struct with following options and default values\n\n  T::DataType=Float32                 # number format\n\n  Tprog::DataType=T                   # number format for prognostic variables\n  Tcomm::DataType=Tprog               # number format for ghost-point copies\n\n  # DOMAIN RESOLUTION AND RATIO\n  nx::Int=100                         # number of grid cells in x-direction\n  Lx::Real=2000e3                     # length of the domain in x-direction [m]\n  L_ratio::Real=2                     # Domain aspect ratio of Lx/Ly\n  ...","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"They can be changed with keyword arguments. The number format T is defined as the first (but optional) argument of RunModel(T,...)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> Prog = run_model(Float32,Ndays=10,g=10,H=500,Fx0=0.12);\nStarting ShallowWaters on Sun, 20 Oct 2019 19:58:25 without output.\n100% Integration done in 4.65s.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"or by creating a Parameter struct","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> P = Parameter(bc=\"nonperiodic\",wind_forcing_x=\"double_gyre\",L_ratio=1,nx=128);\njulia> Prog = run_model(P);","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The number formats can be different (aka mixed-precision) for different parts of the model. Tprog is the number type for the prognostic variables, Tcomm is used for communication of boundary values.","category":"page"},{"location":"#Double-gyre-example","page":"Introduction","title":"Double-gyre example","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"You can for example run a double gyre simulation like this","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using ShallowWaters\njulia> P = run_model(Ndays=100,nx=100,L_ratio=1,bc=\"nonperiodic\",wind_forcing_x=\"double_gyre\",topography=\"seamount\");\nStarting ShallowWaters on Sat, 15 Aug 2020 11:59:21 without output.\n100% Integration done in 13.7s.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Sea surface height can be visualised via","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using PyPlot\njulia> pcolormesh(P.η')","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Figure_1)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Or let's calculate the speed of the currents","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> speed = sqrt.(Ix(P.u.^2)[:,2:end-1] + Iy(P.v.^2)[2:end-1,:])","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"P.u and P.v are the u,v velocity components on the Arakawa C-grid. To add them, we need to interpolate them with Ix,Iy (which are exported by ShallowWaters.jl too), then chopping off the edges to get two arrays of the same size.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> pcolormesh(speed')","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Figure_2)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Such that the currents are strongest around the two eddies, as expected in this quasi-geostrophic setup.","category":"page"},{"location":"#(Some)-Features","page":"Introduction","title":"(Some) Features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Interpolation of initial conditions from low resolution / high resolution runs.\nOutput of relative vorticity, potential vorticity and tendencies du,dv,deta\n(Pretty accurate) duration estimate\nCan be run in ensemble mode with ordered non-conflicting output files\nRuns at CFL=1 (RK4), and more with the strong stability-preserving Runge-Kutta methods\nSolving the tracer advection comes at basically no cost, thanks to semi-Lagrangian advection scheme\nAlso outputs the gradient operators ∂/∂x,∂/∂y and interpolations Ix, Iy for easier post-processing.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"ShallowWaters.jl is a registered package, so simply do","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> ] add ShallowWaters","category":"page"},{"location":"#References","page":"Introduction","title":"References","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"ShallowWaters.jl was used and is described in more detail in  ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Klöwer M, Düben PD, Palmer TN. Number formats, error mitigation and scope for 16-bit arithmetics in weather and climate modelling analysed with a shallow water model. Journal of Advances in Modeling Earth Systems. doi: 10.1029/2020MS002246","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Klöwer M, Düben PD, Palmer TN. Posits as an alternative to floats for weather and climate models. In: Proceedings of the Conference for Next Generation Arithmetic 2019. doi: 10.1145/3316279.3316281","category":"page"},{"location":"#The-equations","page":"Introduction","title":"The equations","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The non-linear shallow water model plus tracer equation is","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"      ∂u/∂t + (u⃗⋅∇)u - f*v = -g*∂η/∂x - c_D*|u⃗|*u + ∇⋅ν*∇(∇²u) + Fx(x,y)     (1)\n      ∂v/∂t + (u⃗⋅∇)v + f*u = -g*∂η/∂y - c_D*|u⃗|*v + ∇⋅ν*∇(∇²v) + Fy(x,y)     (2)\n      ∂η/∂t = -∇⋅(u⃗h) + γ*(η_ref - η) + Fηt(t)*Fη(x,y)                       (3)\n      ∂ϕ/∂t = -u⃗⋅∇ϕ                                                          (4)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"with the prognostic variables velocity u⃗ = (u,v) and sea surface heigth η. The layer thickness is h = η + H(x,y). The Coriolis parameter is f = f₀ + βy with beta-plane approximation. The graviational acceleration is g. Bottom friction is either quadratic with drag coefficient cD or linear with inverse time scale r. Diffusion is realized with a biharmonic diffusion operator, with either a constant viscosity coefficient ν, or a Smagorinsky-like coefficient that scales as ν = cSmag*|D|, with deformation rate |D| = √((∂u/∂x - ∂v/∂y)² + (∂u/∂y + ∂v/∂x)²). Wind forcing Fx is constant in time, but may vary in space.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The linear shallow water model equivalent is","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"      ∂u/∂t - f*v = -g*∂η/∂x - r*u + ∇⋅ν*∇(∇²u) + Fx(x,y)     (1)\n      ∂v/∂t + f*u = -g*∂η/∂y - r*v + ∇⋅ν*∇(∇²v) + Fy(x,y)     (2)\n      ∂η/∂t = -H*∇⋅u⃗ + γ*(η_ref - η) + Fηt(t)*Fη(x,y)         (3)\n      ∂ϕ/∂t = -u⃗⋅∇ϕ                                           (4)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"ShallowWaters.jl discretises the equation on an equi-distant Arakawa C-grid, with 2nd order finite-difference operators. Boundary conditions are implemented via a ghost-point copy and each variable has a halo of variable size to account for different stencil sizes of various operators.","category":"page"}]
}
